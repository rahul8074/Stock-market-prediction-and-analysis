{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nimport { __assign, __extends } from \"tslib\";\nimport { MDCFoundation } from '@material/base/foundation';\nimport { numbers, strings } from './constants';\nvar ACCEPTABLE_KEYS = new Set(); // IE11 has no support for new Set with iterable so we need to initialize this by hand\n\nACCEPTABLE_KEYS.add(strings.ARROW_LEFT_KEY);\nACCEPTABLE_KEYS.add(strings.ARROW_RIGHT_KEY);\nACCEPTABLE_KEYS.add(strings.END_KEY);\nACCEPTABLE_KEYS.add(strings.HOME_KEY);\nACCEPTABLE_KEYS.add(strings.ENTER_KEY);\nACCEPTABLE_KEYS.add(strings.SPACE_KEY);\nvar KEYCODE_MAP = new Map(); // IE11 has no support for new Map with iterable so we need to initialize this by hand\n\nKEYCODE_MAP.set(numbers.ARROW_LEFT_KEYCODE, strings.ARROW_LEFT_KEY);\nKEYCODE_MAP.set(numbers.ARROW_RIGHT_KEYCODE, strings.ARROW_RIGHT_KEY);\nKEYCODE_MAP.set(numbers.END_KEYCODE, strings.END_KEY);\nKEYCODE_MAP.set(numbers.HOME_KEYCODE, strings.HOME_KEY);\nKEYCODE_MAP.set(numbers.ENTER_KEYCODE, strings.ENTER_KEY);\nKEYCODE_MAP.set(numbers.SPACE_KEYCODE, strings.SPACE_KEY);\n\nvar MDCTabBarFoundation =\n/** @class */\nfunction (_super) {\n  __extends(MDCTabBarFoundation, _super);\n\n  function MDCTabBarFoundation(adapter) {\n    var _this = _super.call(this, __assign(__assign({}, MDCTabBarFoundation.defaultAdapter), adapter)) || this;\n\n    _this.useAutomaticActivation_ = false;\n    return _this;\n  }\n\n  Object.defineProperty(MDCTabBarFoundation, \"strings\", {\n    get: function () {\n      return strings;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MDCTabBarFoundation, \"numbers\", {\n    get: function () {\n      return numbers;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MDCTabBarFoundation, \"defaultAdapter\", {\n    get: function () {\n      // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.\n      return {\n        scrollTo: function () {\n          return undefined;\n        },\n        incrementScroll: function () {\n          return undefined;\n        },\n        getScrollPosition: function () {\n          return 0;\n        },\n        getScrollContentWidth: function () {\n          return 0;\n        },\n        getOffsetWidth: function () {\n          return 0;\n        },\n        isRTL: function () {\n          return false;\n        },\n        setActiveTab: function () {\n          return undefined;\n        },\n        activateTabAtIndex: function () {\n          return undefined;\n        },\n        deactivateTabAtIndex: function () {\n          return undefined;\n        },\n        focusTabAtIndex: function () {\n          return undefined;\n        },\n        getTabIndicatorClientRectAtIndex: function () {\n          return {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0,\n            width: 0,\n            height: 0\n          };\n        },\n        getTabDimensionsAtIndex: function () {\n          return {\n            rootLeft: 0,\n            rootRight: 0,\n            contentLeft: 0,\n            contentRight: 0\n          };\n        },\n        getPreviousActiveTabIndex: function () {\n          return -1;\n        },\n        getFocusedTabIndex: function () {\n          return -1;\n        },\n        getIndexOfTabById: function () {\n          return -1;\n        },\n        getTabListLength: function () {\n          return 0;\n        },\n        notifyTabActivated: function () {\n          return undefined;\n        }\n      }; // tslint:enable:object-literal-sort-keys\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Switches between automatic and manual activation modes.\n   * See https://www.w3.org/TR/wai-aria-practices/#tabpanel for examples.\n   */\n\n  MDCTabBarFoundation.prototype.setUseAutomaticActivation = function (useAutomaticActivation) {\n    this.useAutomaticActivation_ = useAutomaticActivation;\n  };\n\n  MDCTabBarFoundation.prototype.activateTab = function (index) {\n    var previousActiveIndex = this.adapter.getPreviousActiveTabIndex();\n\n    if (!this.indexIsInRange_(index) || index === previousActiveIndex) {\n      return;\n    }\n\n    var previousClientRect;\n\n    if (previousActiveIndex !== -1) {\n      this.adapter.deactivateTabAtIndex(previousActiveIndex);\n      previousClientRect = this.adapter.getTabIndicatorClientRectAtIndex(previousActiveIndex);\n    }\n\n    this.adapter.activateTabAtIndex(index, previousClientRect);\n    this.scrollIntoView(index);\n    this.adapter.notifyTabActivated(index);\n  };\n\n  MDCTabBarFoundation.prototype.handleKeyDown = function (evt) {\n    // Get the key from the event\n    var key = this.getKeyFromEvent_(evt); // Early exit if the event key isn't one of the keyboard navigation keys\n\n    if (key === undefined) {\n      return;\n    } // Prevent default behavior for movement keys, but not for activation keys, since :active is used to apply ripple\n\n\n    if (!this.isActivationKey_(key)) {\n      evt.preventDefault();\n    }\n\n    if (this.useAutomaticActivation_) {\n      if (this.isActivationKey_(key)) {\n        return;\n      }\n\n      var index = this.determineTargetFromKey_(this.adapter.getPreviousActiveTabIndex(), key);\n      this.adapter.setActiveTab(index);\n      this.scrollIntoView(index);\n    } else {\n      var focusedTabIndex = this.adapter.getFocusedTabIndex();\n\n      if (this.isActivationKey_(key)) {\n        this.adapter.setActiveTab(focusedTabIndex);\n      } else {\n        var index = this.determineTargetFromKey_(focusedTabIndex, key);\n        this.adapter.focusTabAtIndex(index);\n        this.scrollIntoView(index);\n      }\n    }\n  };\n  /**\n   * Handles the MDCTab:interacted event\n   */\n\n\n  MDCTabBarFoundation.prototype.handleTabInteraction = function (evt) {\n    this.adapter.setActiveTab(this.adapter.getIndexOfTabById(evt.detail.tabId));\n  };\n  /**\n   * Scrolls the tab at the given index into view\n   * @param index The tab index to make visible\n   */\n\n\n  MDCTabBarFoundation.prototype.scrollIntoView = function (index) {\n    // Early exit if the index is out of range\n    if (!this.indexIsInRange_(index)) {\n      return;\n    } // Always scroll to 0 if scrolling to the 0th index\n\n\n    if (index === 0) {\n      return this.adapter.scrollTo(0);\n    } // Always scroll to the max value if scrolling to the Nth index\n    // MDCTabScroller.scrollTo() will never scroll past the max possible value\n\n\n    if (index === this.adapter.getTabListLength() - 1) {\n      return this.adapter.scrollTo(this.adapter.getScrollContentWidth());\n    }\n\n    if (this.isRTL_()) {\n      return this.scrollIntoViewRTL_(index);\n    }\n\n    this.scrollIntoView_(index);\n  };\n  /**\n   * Private method for determining the index of the destination tab based on what key was pressed\n   * @param origin The original index from which to determine the destination\n   * @param key The name of the key\n   */\n\n\n  MDCTabBarFoundation.prototype.determineTargetFromKey_ = function (origin, key) {\n    var isRTL = this.isRTL_();\n    var maxIndex = this.adapter.getTabListLength() - 1;\n    var shouldGoToEnd = key === strings.END_KEY;\n    var shouldDecrement = key === strings.ARROW_LEFT_KEY && !isRTL || key === strings.ARROW_RIGHT_KEY && isRTL;\n    var shouldIncrement = key === strings.ARROW_RIGHT_KEY && !isRTL || key === strings.ARROW_LEFT_KEY && isRTL;\n    var index = origin;\n\n    if (shouldGoToEnd) {\n      index = maxIndex;\n    } else if (shouldDecrement) {\n      index -= 1;\n    } else if (shouldIncrement) {\n      index += 1;\n    } else {\n      index = 0;\n    }\n\n    if (index < 0) {\n      index = maxIndex;\n    } else if (index > maxIndex) {\n      index = 0;\n    }\n\n    return index;\n  };\n  /**\n   * Calculates the scroll increment that will make the tab at the given index visible\n   * @param index The index of the tab\n   * @param nextIndex The index of the next tab\n   * @param scrollPosition The current scroll position\n   * @param barWidth The width of the Tab Bar\n   */\n\n\n  MDCTabBarFoundation.prototype.calculateScrollIncrement_ = function (index, nextIndex, scrollPosition, barWidth) {\n    var nextTabDimensions = this.adapter.getTabDimensionsAtIndex(nextIndex);\n    var relativeContentLeft = nextTabDimensions.contentLeft - scrollPosition - barWidth;\n    var relativeContentRight = nextTabDimensions.contentRight - scrollPosition;\n    var leftIncrement = relativeContentRight - numbers.EXTRA_SCROLL_AMOUNT;\n    var rightIncrement = relativeContentLeft + numbers.EXTRA_SCROLL_AMOUNT;\n\n    if (nextIndex < index) {\n      return Math.min(leftIncrement, 0);\n    }\n\n    return Math.max(rightIncrement, 0);\n  };\n  /**\n   * Calculates the scroll increment that will make the tab at the given index visible in RTL\n   * @param index The index of the tab\n   * @param nextIndex The index of the next tab\n   * @param scrollPosition The current scroll position\n   * @param barWidth The width of the Tab Bar\n   * @param scrollContentWidth The width of the scroll content\n   */\n\n\n  MDCTabBarFoundation.prototype.calculateScrollIncrementRTL_ = function (index, nextIndex, scrollPosition, barWidth, scrollContentWidth) {\n    var nextTabDimensions = this.adapter.getTabDimensionsAtIndex(nextIndex);\n    var relativeContentLeft = scrollContentWidth - nextTabDimensions.contentLeft - scrollPosition;\n    var relativeContentRight = scrollContentWidth - nextTabDimensions.contentRight - scrollPosition - barWidth;\n    var leftIncrement = relativeContentRight + numbers.EXTRA_SCROLL_AMOUNT;\n    var rightIncrement = relativeContentLeft - numbers.EXTRA_SCROLL_AMOUNT;\n\n    if (nextIndex > index) {\n      return Math.max(leftIncrement, 0);\n    }\n\n    return Math.min(rightIncrement, 0);\n  };\n  /**\n   * Determines the index of the adjacent tab closest to either edge of the Tab Bar\n   * @param index The index of the tab\n   * @param tabDimensions The dimensions of the tab\n   * @param scrollPosition The current scroll position\n   * @param barWidth The width of the tab bar\n   */\n\n\n  MDCTabBarFoundation.prototype.findAdjacentTabIndexClosestToEdge_ = function (index, tabDimensions, scrollPosition, barWidth) {\n    /**\n     * Tabs are laid out in the Tab Scroller like this:\n     *\n     *    Scroll Position\n     *    +---+\n     *    |   |   Bar Width\n     *    |   +-----------------------------------+\n     *    |   |                                   |\n     *    |   V                                   V\n     *    |   +-----------------------------------+\n     *    V   |             Tab Scroller          |\n     *    +------------+--------------+-------------------+\n     *    |    Tab     |      Tab     |        Tab        |\n     *    +------------+--------------+-------------------+\n     *        |                                   |\n     *        +-----------------------------------+\n     *\n     * To determine the next adjacent index, we look at the Tab root left and\n     * Tab root right, both relative to the scroll position. If the Tab root\n     * left is less than 0, then we know it's out of view to the left. If the\n     * Tab root right minus the bar width is greater than 0, we know the Tab is\n     * out of view to the right. From there, we either increment or decrement\n     * the index.\n     */\n    var relativeRootLeft = tabDimensions.rootLeft - scrollPosition;\n    var relativeRootRight = tabDimensions.rootRight - scrollPosition - barWidth;\n    var relativeRootDelta = relativeRootLeft + relativeRootRight;\n    var leftEdgeIsCloser = relativeRootLeft < 0 || relativeRootDelta < 0;\n    var rightEdgeIsCloser = relativeRootRight > 0 || relativeRootDelta > 0;\n\n    if (leftEdgeIsCloser) {\n      return index - 1;\n    }\n\n    if (rightEdgeIsCloser) {\n      return index + 1;\n    }\n\n    return -1;\n  };\n  /**\n   * Determines the index of the adjacent tab closest to either edge of the Tab Bar in RTL\n   * @param index The index of the tab\n   * @param tabDimensions The dimensions of the tab\n   * @param scrollPosition The current scroll position\n   * @param barWidth The width of the tab bar\n   * @param scrollContentWidth The width of the scroller content\n   */\n\n\n  MDCTabBarFoundation.prototype.findAdjacentTabIndexClosestToEdgeRTL_ = function (index, tabDimensions, scrollPosition, barWidth, scrollContentWidth) {\n    var rootLeft = scrollContentWidth - tabDimensions.rootLeft - barWidth - scrollPosition;\n    var rootRight = scrollContentWidth - tabDimensions.rootRight - scrollPosition;\n    var rootDelta = rootLeft + rootRight;\n    var leftEdgeIsCloser = rootLeft > 0 || rootDelta > 0;\n    var rightEdgeIsCloser = rootRight < 0 || rootDelta < 0;\n\n    if (leftEdgeIsCloser) {\n      return index + 1;\n    }\n\n    if (rightEdgeIsCloser) {\n      return index - 1;\n    }\n\n    return -1;\n  };\n  /**\n   * Returns the key associated with a keydown event\n   * @param evt The keydown event\n   */\n\n\n  MDCTabBarFoundation.prototype.getKeyFromEvent_ = function (evt) {\n    if (ACCEPTABLE_KEYS.has(evt.key)) {\n      return evt.key;\n    }\n\n    return KEYCODE_MAP.get(evt.keyCode);\n  };\n\n  MDCTabBarFoundation.prototype.isActivationKey_ = function (key) {\n    return key === strings.SPACE_KEY || key === strings.ENTER_KEY;\n  };\n  /**\n   * Returns whether a given index is inclusively between the ends\n   * @param index The index to test\n   */\n\n\n  MDCTabBarFoundation.prototype.indexIsInRange_ = function (index) {\n    return index >= 0 && index < this.adapter.getTabListLength();\n  };\n  /**\n   * Returns the view's RTL property\n   */\n\n\n  MDCTabBarFoundation.prototype.isRTL_ = function () {\n    return this.adapter.isRTL();\n  };\n  /**\n   * Scrolls the tab at the given index into view for left-to-right user agents.\n   * @param index The index of the tab to scroll into view\n   */\n\n\n  MDCTabBarFoundation.prototype.scrollIntoView_ = function (index) {\n    var scrollPosition = this.adapter.getScrollPosition();\n    var barWidth = this.adapter.getOffsetWidth();\n    var tabDimensions = this.adapter.getTabDimensionsAtIndex(index);\n    var nextIndex = this.findAdjacentTabIndexClosestToEdge_(index, tabDimensions, scrollPosition, barWidth);\n\n    if (!this.indexIsInRange_(nextIndex)) {\n      return;\n    }\n\n    var scrollIncrement = this.calculateScrollIncrement_(index, nextIndex, scrollPosition, barWidth);\n    this.adapter.incrementScroll(scrollIncrement);\n  };\n  /**\n   * Scrolls the tab at the given index into view in RTL\n   * @param index The tab index to make visible\n   */\n\n\n  MDCTabBarFoundation.prototype.scrollIntoViewRTL_ = function (index) {\n    var scrollPosition = this.adapter.getScrollPosition();\n    var barWidth = this.adapter.getOffsetWidth();\n    var tabDimensions = this.adapter.getTabDimensionsAtIndex(index);\n    var scrollWidth = this.adapter.getScrollContentWidth();\n    var nextIndex = this.findAdjacentTabIndexClosestToEdgeRTL_(index, tabDimensions, scrollPosition, barWidth, scrollWidth);\n\n    if (!this.indexIsInRange_(nextIndex)) {\n      return;\n    }\n\n    var scrollIncrement = this.calculateScrollIncrementRTL_(index, nextIndex, scrollPosition, barWidth, scrollWidth);\n    this.adapter.incrementScroll(scrollIncrement);\n  };\n\n  return MDCTabBarFoundation;\n}(MDCFoundation);\n\nexport { MDCTabBarFoundation }; // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\n\nexport default MDCTabBarFoundation;","map":{"version":3,"sources":["foundation.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nimport { __assign, __extends } from \"tslib\";\nimport { MDCFoundation } from '@material/base/foundation';\nimport { numbers, strings } from './constants';\nvar ACCEPTABLE_KEYS = new Set();\n// IE11 has no support for new Set with iterable so we need to initialize this by hand\nACCEPTABLE_KEYS.add(strings.ARROW_LEFT_KEY);\nACCEPTABLE_KEYS.add(strings.ARROW_RIGHT_KEY);\nACCEPTABLE_KEYS.add(strings.END_KEY);\nACCEPTABLE_KEYS.add(strings.HOME_KEY);\nACCEPTABLE_KEYS.add(strings.ENTER_KEY);\nACCEPTABLE_KEYS.add(strings.SPACE_KEY);\nvar KEYCODE_MAP = new Map();\n// IE11 has no support for new Map with iterable so we need to initialize this by hand\nKEYCODE_MAP.set(numbers.ARROW_LEFT_KEYCODE, strings.ARROW_LEFT_KEY);\nKEYCODE_MAP.set(numbers.ARROW_RIGHT_KEYCODE, strings.ARROW_RIGHT_KEY);\nKEYCODE_MAP.set(numbers.END_KEYCODE, strings.END_KEY);\nKEYCODE_MAP.set(numbers.HOME_KEYCODE, strings.HOME_KEY);\nKEYCODE_MAP.set(numbers.ENTER_KEYCODE, strings.ENTER_KEY);\nKEYCODE_MAP.set(numbers.SPACE_KEYCODE, strings.SPACE_KEY);\nvar MDCTabBarFoundation = /** @class */ (function (_super) {\n    __extends(MDCTabBarFoundation, _super);\n    function MDCTabBarFoundation(adapter) {\n        var _this = _super.call(this, __assign(__assign({}, MDCTabBarFoundation.defaultAdapter), adapter)) || this;\n        _this.useAutomaticActivation_ = false;\n        return _this;\n    }\n    Object.defineProperty(MDCTabBarFoundation, \"strings\", {\n        get: function () {\n            return strings;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCTabBarFoundation, \"numbers\", {\n        get: function () {\n            return numbers;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MDCTabBarFoundation, \"defaultAdapter\", {\n        get: function () {\n            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.\n            return {\n                scrollTo: function () { return undefined; },\n                incrementScroll: function () { return undefined; },\n                getScrollPosition: function () { return 0; },\n                getScrollContentWidth: function () { return 0; },\n                getOffsetWidth: function () { return 0; },\n                isRTL: function () { return false; },\n                setActiveTab: function () { return undefined; },\n                activateTabAtIndex: function () { return undefined; },\n                deactivateTabAtIndex: function () { return undefined; },\n                focusTabAtIndex: function () { return undefined; },\n                getTabIndicatorClientRectAtIndex: function () { return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }); },\n                getTabDimensionsAtIndex: function () { return ({ rootLeft: 0, rootRight: 0, contentLeft: 0, contentRight: 0 }); },\n                getPreviousActiveTabIndex: function () { return -1; },\n                getFocusedTabIndex: function () { return -1; },\n                getIndexOfTabById: function () { return -1; },\n                getTabListLength: function () { return 0; },\n                notifyTabActivated: function () { return undefined; },\n            };\n            // tslint:enable:object-literal-sort-keys\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Switches between automatic and manual activation modes.\n     * See https://www.w3.org/TR/wai-aria-practices/#tabpanel for examples.\n     */\n    MDCTabBarFoundation.prototype.setUseAutomaticActivation = function (useAutomaticActivation) {\n        this.useAutomaticActivation_ = useAutomaticActivation;\n    };\n    MDCTabBarFoundation.prototype.activateTab = function (index) {\n        var previousActiveIndex = this.adapter.getPreviousActiveTabIndex();\n        if (!this.indexIsInRange_(index) || index === previousActiveIndex) {\n            return;\n        }\n        var previousClientRect;\n        if (previousActiveIndex !== -1) {\n            this.adapter.deactivateTabAtIndex(previousActiveIndex);\n            previousClientRect =\n                this.adapter.getTabIndicatorClientRectAtIndex(previousActiveIndex);\n        }\n        this.adapter.activateTabAtIndex(index, previousClientRect);\n        this.scrollIntoView(index);\n        this.adapter.notifyTabActivated(index);\n    };\n    MDCTabBarFoundation.prototype.handleKeyDown = function (evt) {\n        // Get the key from the event\n        var key = this.getKeyFromEvent_(evt);\n        // Early exit if the event key isn't one of the keyboard navigation keys\n        if (key === undefined) {\n            return;\n        }\n        // Prevent default behavior for movement keys, but not for activation keys, since :active is used to apply ripple\n        if (!this.isActivationKey_(key)) {\n            evt.preventDefault();\n        }\n        if (this.useAutomaticActivation_) {\n            if (this.isActivationKey_(key)) {\n                return;\n            }\n            var index = this.determineTargetFromKey_(this.adapter.getPreviousActiveTabIndex(), key);\n            this.adapter.setActiveTab(index);\n            this.scrollIntoView(index);\n        }\n        else {\n            var focusedTabIndex = this.adapter.getFocusedTabIndex();\n            if (this.isActivationKey_(key)) {\n                this.adapter.setActiveTab(focusedTabIndex);\n            }\n            else {\n                var index = this.determineTargetFromKey_(focusedTabIndex, key);\n                this.adapter.focusTabAtIndex(index);\n                this.scrollIntoView(index);\n            }\n        }\n    };\n    /**\n     * Handles the MDCTab:interacted event\n     */\n    MDCTabBarFoundation.prototype.handleTabInteraction = function (evt) {\n        this.adapter.setActiveTab(this.adapter.getIndexOfTabById(evt.detail.tabId));\n    };\n    /**\n     * Scrolls the tab at the given index into view\n     * @param index The tab index to make visible\n     */\n    MDCTabBarFoundation.prototype.scrollIntoView = function (index) {\n        // Early exit if the index is out of range\n        if (!this.indexIsInRange_(index)) {\n            return;\n        }\n        // Always scroll to 0 if scrolling to the 0th index\n        if (index === 0) {\n            return this.adapter.scrollTo(0);\n        }\n        // Always scroll to the max value if scrolling to the Nth index\n        // MDCTabScroller.scrollTo() will never scroll past the max possible value\n        if (index === this.adapter.getTabListLength() - 1) {\n            return this.adapter.scrollTo(this.adapter.getScrollContentWidth());\n        }\n        if (this.isRTL_()) {\n            return this.scrollIntoViewRTL_(index);\n        }\n        this.scrollIntoView_(index);\n    };\n    /**\n     * Private method for determining the index of the destination tab based on what key was pressed\n     * @param origin The original index from which to determine the destination\n     * @param key The name of the key\n     */\n    MDCTabBarFoundation.prototype.determineTargetFromKey_ = function (origin, key) {\n        var isRTL = this.isRTL_();\n        var maxIndex = this.adapter.getTabListLength() - 1;\n        var shouldGoToEnd = key === strings.END_KEY;\n        var shouldDecrement = key === strings.ARROW_LEFT_KEY && !isRTL || key === strings.ARROW_RIGHT_KEY && isRTL;\n        var shouldIncrement = key === strings.ARROW_RIGHT_KEY && !isRTL || key === strings.ARROW_LEFT_KEY && isRTL;\n        var index = origin;\n        if (shouldGoToEnd) {\n            index = maxIndex;\n        }\n        else if (shouldDecrement) {\n            index -= 1;\n        }\n        else if (shouldIncrement) {\n            index += 1;\n        }\n        else {\n            index = 0;\n        }\n        if (index < 0) {\n            index = maxIndex;\n        }\n        else if (index > maxIndex) {\n            index = 0;\n        }\n        return index;\n    };\n    /**\n     * Calculates the scroll increment that will make the tab at the given index visible\n     * @param index The index of the tab\n     * @param nextIndex The index of the next tab\n     * @param scrollPosition The current scroll position\n     * @param barWidth The width of the Tab Bar\n     */\n    MDCTabBarFoundation.prototype.calculateScrollIncrement_ = function (index, nextIndex, scrollPosition, barWidth) {\n        var nextTabDimensions = this.adapter.getTabDimensionsAtIndex(nextIndex);\n        var relativeContentLeft = nextTabDimensions.contentLeft - scrollPosition - barWidth;\n        var relativeContentRight = nextTabDimensions.contentRight - scrollPosition;\n        var leftIncrement = relativeContentRight - numbers.EXTRA_SCROLL_AMOUNT;\n        var rightIncrement = relativeContentLeft + numbers.EXTRA_SCROLL_AMOUNT;\n        if (nextIndex < index) {\n            return Math.min(leftIncrement, 0);\n        }\n        return Math.max(rightIncrement, 0);\n    };\n    /**\n     * Calculates the scroll increment that will make the tab at the given index visible in RTL\n     * @param index The index of the tab\n     * @param nextIndex The index of the next tab\n     * @param scrollPosition The current scroll position\n     * @param barWidth The width of the Tab Bar\n     * @param scrollContentWidth The width of the scroll content\n     */\n    MDCTabBarFoundation.prototype.calculateScrollIncrementRTL_ = function (index, nextIndex, scrollPosition, barWidth, scrollContentWidth) {\n        var nextTabDimensions = this.adapter.getTabDimensionsAtIndex(nextIndex);\n        var relativeContentLeft = scrollContentWidth - nextTabDimensions.contentLeft - scrollPosition;\n        var relativeContentRight = scrollContentWidth - nextTabDimensions.contentRight - scrollPosition - barWidth;\n        var leftIncrement = relativeContentRight + numbers.EXTRA_SCROLL_AMOUNT;\n        var rightIncrement = relativeContentLeft - numbers.EXTRA_SCROLL_AMOUNT;\n        if (nextIndex > index) {\n            return Math.max(leftIncrement, 0);\n        }\n        return Math.min(rightIncrement, 0);\n    };\n    /**\n     * Determines the index of the adjacent tab closest to either edge of the Tab Bar\n     * @param index The index of the tab\n     * @param tabDimensions The dimensions of the tab\n     * @param scrollPosition The current scroll position\n     * @param barWidth The width of the tab bar\n     */\n    MDCTabBarFoundation.prototype.findAdjacentTabIndexClosestToEdge_ = function (index, tabDimensions, scrollPosition, barWidth) {\n        /**\n         * Tabs are laid out in the Tab Scroller like this:\n         *\n         *    Scroll Position\n         *    +---+\n         *    |   |   Bar Width\n         *    |   +-----------------------------------+\n         *    |   |                                   |\n         *    |   V                                   V\n         *    |   +-----------------------------------+\n         *    V   |             Tab Scroller          |\n         *    +------------+--------------+-------------------+\n         *    |    Tab     |      Tab     |        Tab        |\n         *    +------------+--------------+-------------------+\n         *        |                                   |\n         *        +-----------------------------------+\n         *\n         * To determine the next adjacent index, we look at the Tab root left and\n         * Tab root right, both relative to the scroll position. If the Tab root\n         * left is less than 0, then we know it's out of view to the left. If the\n         * Tab root right minus the bar width is greater than 0, we know the Tab is\n         * out of view to the right. From there, we either increment or decrement\n         * the index.\n         */\n        var relativeRootLeft = tabDimensions.rootLeft - scrollPosition;\n        var relativeRootRight = tabDimensions.rootRight - scrollPosition - barWidth;\n        var relativeRootDelta = relativeRootLeft + relativeRootRight;\n        var leftEdgeIsCloser = relativeRootLeft < 0 || relativeRootDelta < 0;\n        var rightEdgeIsCloser = relativeRootRight > 0 || relativeRootDelta > 0;\n        if (leftEdgeIsCloser) {\n            return index - 1;\n        }\n        if (rightEdgeIsCloser) {\n            return index + 1;\n        }\n        return -1;\n    };\n    /**\n     * Determines the index of the adjacent tab closest to either edge of the Tab Bar in RTL\n     * @param index The index of the tab\n     * @param tabDimensions The dimensions of the tab\n     * @param scrollPosition The current scroll position\n     * @param barWidth The width of the tab bar\n     * @param scrollContentWidth The width of the scroller content\n     */\n    MDCTabBarFoundation.prototype.findAdjacentTabIndexClosestToEdgeRTL_ = function (index, tabDimensions, scrollPosition, barWidth, scrollContentWidth) {\n        var rootLeft = scrollContentWidth - tabDimensions.rootLeft - barWidth - scrollPosition;\n        var rootRight = scrollContentWidth - tabDimensions.rootRight - scrollPosition;\n        var rootDelta = rootLeft + rootRight;\n        var leftEdgeIsCloser = rootLeft > 0 || rootDelta > 0;\n        var rightEdgeIsCloser = rootRight < 0 || rootDelta < 0;\n        if (leftEdgeIsCloser) {\n            return index + 1;\n        }\n        if (rightEdgeIsCloser) {\n            return index - 1;\n        }\n        return -1;\n    };\n    /**\n     * Returns the key associated with a keydown event\n     * @param evt The keydown event\n     */\n    MDCTabBarFoundation.prototype.getKeyFromEvent_ = function (evt) {\n        if (ACCEPTABLE_KEYS.has(evt.key)) {\n            return evt.key;\n        }\n        return KEYCODE_MAP.get(evt.keyCode);\n    };\n    MDCTabBarFoundation.prototype.isActivationKey_ = function (key) {\n        return key === strings.SPACE_KEY || key === strings.ENTER_KEY;\n    };\n    /**\n     * Returns whether a given index is inclusively between the ends\n     * @param index The index to test\n     */\n    MDCTabBarFoundation.prototype.indexIsInRange_ = function (index) {\n        return index >= 0 && index < this.adapter.getTabListLength();\n    };\n    /**\n     * Returns the view's RTL property\n     */\n    MDCTabBarFoundation.prototype.isRTL_ = function () {\n        return this.adapter.isRTL();\n    };\n    /**\n     * Scrolls the tab at the given index into view for left-to-right user agents.\n     * @param index The index of the tab to scroll into view\n     */\n    MDCTabBarFoundation.prototype.scrollIntoView_ = function (index) {\n        var scrollPosition = this.adapter.getScrollPosition();\n        var barWidth = this.adapter.getOffsetWidth();\n        var tabDimensions = this.adapter.getTabDimensionsAtIndex(index);\n        var nextIndex = this.findAdjacentTabIndexClosestToEdge_(index, tabDimensions, scrollPosition, barWidth);\n        if (!this.indexIsInRange_(nextIndex)) {\n            return;\n        }\n        var scrollIncrement = this.calculateScrollIncrement_(index, nextIndex, scrollPosition, barWidth);\n        this.adapter.incrementScroll(scrollIncrement);\n    };\n    /**\n     * Scrolls the tab at the given index into view in RTL\n     * @param index The tab index to make visible\n     */\n    MDCTabBarFoundation.prototype.scrollIntoViewRTL_ = function (index) {\n        var scrollPosition = this.adapter.getScrollPosition();\n        var barWidth = this.adapter.getOffsetWidth();\n        var tabDimensions = this.adapter.getTabDimensionsAtIndex(index);\n        var scrollWidth = this.adapter.getScrollContentWidth();\n        var nextIndex = this.findAdjacentTabIndexClosestToEdgeRTL_(index, tabDimensions, scrollPosition, barWidth, scrollWidth);\n        if (!this.indexIsInRange_(nextIndex)) {\n            return;\n        }\n        var scrollIncrement = this.calculateScrollIncrementRTL_(index, nextIndex, scrollPosition, barWidth, scrollWidth);\n        this.adapter.incrementScroll(scrollIncrement);\n    };\n    return MDCTabBarFoundation;\n}(MDCFoundation));\nexport { MDCTabBarFoundation };\n// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\nexport default MDCTabBarFoundation;\n//# sourceMappingURL=foundation.js.map"]},"metadata":{},"sourceType":"module"}